<!DOCTYPE html>
<title>Applesoft BASIC Reference</title>
<style type="text/css">
body { background-color: #EEEACD; color: black; }
#toc { float: right; background-color: #DDDABD; font-size: 80%;}
code, dt { font-family: 'Lucida Console', 'Courier New', Courier, monospace; font-weight: bold; font-size: 80%; }

h2 { border-top: solid 1px black; border-bottom: solid 1px black; }
</style>

<div id="toc"></div>

<h1>Applesoft BASIC Quick Reference</h1>

<p>
This is intended as a quick reference for the <a href="index.htm">Applesoft BASIC in JavaScript</a> by <a href="mailto:inexorabletash@hotmail.com">Joshua Bell</a>.
</p>

<p>
<a href="#Extensions">Extensions</a> beyond Applesoft BASIC are called out with footnotes.
</p>

<p>See also:</p>
<ul>
	<li><a href="http://www.landsnail.com/a2ref.htm">Apple II Programmer's Reference: Applesoft Commands</a>
	<li><a href="http://www.apple2.org/faq/FAQ.applesoft.html">Applesoft BASIC Frequently Asked Questions (FAQ)</a>
	<li><a href="http://www.lazilong.com/apple_II/bbros/">Beagle Bros. Peeks, Pokes & Pointers Chart (Colors, ASCII values, etc)</a>
	<li><a href="http://beagle.applearchives.com/posters.htm">More Beagle Bros. Posters - including Apple Commands Chart, in PDF format</a>
</ul>



<!-- ================================================== -->
<h2 id="Statements">Statements</h2>
<!-- ================================================== -->

<h3>Variable Control</h3>
<dl>
    <dt>CLEAR<dd>Clear all variables
    <dt>[LET] <var>var</var> = <var>expr</var><dd>Assign variable
    <dt>DIM <var>var</var>( <var>size</var> [ , <var>size2</var> ...] ) [ , <var>var2</var>( <var>size</var> [ , <var>size2</var> ...] ) ... ] <dd>Allocate array
    <dt>DEF FN <var>f</var>(<var>var</var> ) = <var>expr</var><dd>Define function of a single variable <a href="#Extension_StringFuncs">[1]</a>
</dl>
<h3>Flow Control</h3>
<dl>
    <dt>GOTO<dd>Go to line number
    <dt>GOSUB <var>line</var><dd>Go to subroutine
    <dt>RETURN<dd>Return from subroutine
    <dt>ON <var>expr</var> GOTO <var>line</var> [, <var>line2</var> ... ]<dd>Branch based on index (value = 1, 2, ...)
    <dt>ON <var>expr</var> GOSUB <var>line</var> [, <var>line2</var> ... ]<dd>Subroutine branch based on index (value = 1, 2, ...)
    <dt>POP<dd>Convert last gosub into a goto
    <dt>FOR <var>var</var> = <var>start</var> TO <var>end</var> [ STEP <var>incr</var> ]<dd>Loop with counter variable
    <dt>NEXT [<var>var</var> [, <var>var</var> ...] ]<dd>End of loop(s)
    <dt>IF <var>expr</var> THEN <var>statement</var><br />IF <var>expr</var> GOTO <var>line</var><dd>Conditional; if expr is false, rest of line is skipped
    <dt>END<dd>Terminate program
    <dt>STOP<dd>Break, as if an error occurred
</dl>
<h3>Error Handling</h3>
<dl>
    <dt>ONERR GOTO <var>line</var><dd>Set error hook
    <dt>RESUME<dd>Retry line that caused ONERR GOTO
</dl>
<h3>Input/Output</h3>
<dl>
    <dt>PRINT <var>expr</var> [ [;,] <var>expr2</var> ... ] [;]<dd>Output text
    <dt>INPUT [<var>string</var> ;] <var>var</var> [, <var>var2</var> ... ]<dd>Read line of input
    <dt>GET <var>var</var><dd>Read single key
    <dt>HOME<dd>Clear text display
    <dt>HTAB <var>expr</var><dd>Position text cursor horizontally
    <dt>VTAB <var>expr</var><dd>Position text cursor vertically
    <dt>INVERSE<dd>Set output mode to black-on-white
    <dt>FLASH<dd>Set output mode to flashing
    <dt>NORMAL<dd>Set output mode to white-on-black
    <dt>TEXT<dd>Set display to text mode
</dl>
<h3>Miscellaneous</h3>
<dl>
    <dt>REM [ <var>comment</var> ]<dd>Begin a comment; rest of line is skipped
    <dt>TRACE<dd>Turn on trace mode (line numbers printed)
    <dt>NOTRACE<dd>Turn off trace mode
</dl>
<h3>Inline Data</h3>
<dl>
    <dt>DATA <var>value</var> [, <var>value2</var> ... ]<dd>Define inline data
    <dt>READ <var>var</var> [, <var>var2</var> ... ]<dd>Read the next DATA value
    <dt>RESTORE<dd>Restore the DATA pointer to the first value
</dl>
<h3>Lo-Res Graphics</h3>
<dl>
    <dt>GR<dd>Set display to lores mode, clear screen
    <dt>COLOR= <var>expr</var><dd>Set lores color (0...15)
    <dt>PLOT <var>expr</var>, <var>expr</var><dd>Plot lores point (x = 0...39, y = 0...40/48)
    <dt>HLIN <var>expr</var>, <var>expr</var> AT <var>expr</var><dd>Plot horizontal line (x1, x2 at y)
    <dt>VLIN <var>expr</var>, <var>expr</var> AT <var>expr</var><dd>Plot vertical line (y1, y2 at x)
</dl>
<h3>Hi-Res Graphics</h3>
<dl>
    <dt>HGR<dd>Set display to hires mode, clear screen
    <dt>HGR2<dd>Set display to hires mode (page 2), clear screen
    <dt>HPLOT [TO] <var>expr</var>, <var>expr</var> [ TO <var>expr</var>, <var>expr</var> ] ... <dd>Plot hires point/line (x=0...279, y=0...191)
    <dt>HCOLOR= <var>expr</var><dd>Set hires color (0...7)
</dl>
<h3>Hi-Res Shape Tables <var>- NOT IMPLEMENTED</var></h3>
<dl>
    <dt>ROT= <var>expr</var><dd>Set hires shape table rotation (0...63)
    <dt>SCALE= <var>expr</var><dd>Set hires shape table scale (1...255)
    <dt>DRAW <var>expr</var> [ AT <var>expr</var>, <var>expr</var> ]<dd>Draw hires shape table shape in color
    <dt>XDRAW <var>expr</var> [ AT <var>expr</var>, <var>expr</var> ]<dd>Draw hires shape table shape with XOR
</dl>
<h3>Interpreter and Program State <var>- NOT IMPLEMENTED</var></h3>
<dl>
    <dt>CONT<dd>Continue from a STOP
    <dt>DEL<dd>Delete lines of program
    <dt>LIST [ <var>expr</var> [, <var>expr</var> ] ]<dd>List lines of program
    <dt>NEW<dd>Clear program and variables
    <dt>RUN [ <var>expr</var> ]<dd>Start program execution at line
</dl>
<h3>Native Platform Interaction <var>- NOT IMPLEMENTED</var></h3>
<dl>
    <dt>HIMEM: <var>expr</var><dd>Set upper address of variable memory
    <dt>IN# <var>expr</var><dd>Direct input from slot
    <dt>LOMEM: <var>expr</var><dd>Set lower address of variable memory
    <dt>WAIT <var>expr</var>, <var>expr</var> [, <var>expr</var>]<dd>Wait until memory location masked by second argument equals third argument (or zero)
</dl>
<h3>Cassette Tape <var>- NOT IMPLEMENTED</var></h3>
<dl>
    <dt>LOAD<dd>Load program from cassette
    <dt>RECALL<dd>Load variables from cassette
    <dt>SAVE<dd>Save program to cassette
    <dt>STORE<dd>Save variables to cassette
    <dt>SHLOAD<dd>Load hires shape table from cassette
</dl>
<h3 id="Compatibility_Shims">Compatibility Shims</h3>
<dl>
    <dt>SPEED= <var>expr</var><dd>Set character output delay - <em>has no effect</em>
    <dt id="Poke">POKE <var>expr</var>, <var>expr</var><dd>Set memory location to value
        <ul>
            <li><code>POKE 32,<var>n</var></code> - Text window left edge
            <li><code>POKE 33,<var>n</var></code> - Text window width
            <li><code>POKE 34,<var>n</var></code> - Text window top edge
            <li><code>POKE 35,<var>n</var></code> - Text window bottom
            <li><code>POKE 36,<var>n</var></code> - Text cursor x
            <li><code>POKE 37,<var>n</var></code> - Text cursor y
            <li><code>POKE 216,<var>n</var></code> - ONERR flag (<var>n</var> &lt; 128 disables ONERR handler)
            <li><code>POKE 230,<var>n</var></code> - Hi-Res plotting page (32 = page 1, 64 = page 2)
            <li><code>POKE 49168,0</code> - clear keyboard strobe
            <li><code>POKE 49200,0</code> - toggle speaker (no-op)
            <li><code>POKE 49232,0</code> - graphics mode
            <li><code>POKE 49233,0</code> - text mode
            <li><code>POKE 49234,0</code> - full graphics
            <li><code>POKE 49235,0</code> - split screen
            <li><code>POKE 49238,0</code> - lores
            <li><code>POKE 49239,0</code> - hires
        </ul>

    <dt id="Call">CALL <var>expr</var><dd>Call native routine
        <ul>
            <li><code>CALL -3100</code> - reveal hi-res page 1
            <li><code>CALL -3086</code> - clear current hi-res page to black
            <li><code>CALL -3082</code> - clear current hi-res page to current color
            <li><code>CALL 54951</code> - clear stack (cancel pending <code>FOR</code>-<code>NEXT</code> loops and <code>GOSUB</code>s)
        </ul>

    <dt>PR# <var>expr</var><dd>Direct output to slot
        <ul>
            <li><code>PR#0</code> - set 40 column mode
            <li><code>PR#3</code> - set 80 column mode
        </ul>

</dl>

<!-- ================================================== -->
<h2>Functions</h2>
<!-- ================================================== -->

<h3>Numeric Functions</h3>
<dl>
    <dt>ABS( <var>expr</var> )<dd>Absolute value of number
    <dt>ATN( <var>expr</var> )<dd>Arctangent of number
    <dt>COS( <var>expr</var> )<dd>Cosine of number
    <dt>EXP( <var>expr</var> )<dd>Raise e to number
    <dt>INT( <var>expr</var> )<dd>Integer part of number
    <dt>LOG( <var>expr</var> )<dd>Natural log of number
    <dt>RND( <var>expr</var> )<dd>Pseudo-random number generator (0 repeats last, negative reseeds)
    <dt>SGN( <var>expr</var> )<dd>Sign of number (-1,0,1)
    <dt>SIN( <var>expr</var> )<dd>Sine of number
    <dt>SQR( <var>expr</var> )<dd>Square root of number
    <dt>TAN( <var>expr</var> )<dd>Tangent of number
</dl>
<h3>String Functions</h3>
<dl>
    <dt>LEN( <var>expr</var> )<dd>Length of string
    <dt>LEFT$( <var>expr</var>, <var>expr</var> )<dd>Left portion of (string, length)
    <dt>MID$( <var>expr</var>, <var>expr</var> [, <var>expr</var>] )<dd>Substring of (string, start character, length)
    <dt>RIGHT$( <var>expr</var>, <var>expr</var> )<dd>Right portion of (string, length)
</dl>
<h3>Type Conversion Functions</h3>
<dl>
    <dt>ASC( <var>expr</var> )<dd>ASCII code for first character of string
    <dt>CHR$( <var>expr</var> )<dd>Character at specified ASCII code point<a href="#Extensions_CHR">[3]</a>
    <dt>STR$( <var>expr</var> )<dd>String representation of number
    <dt>VAL( <var>expr</var> )<dd>Parse string into number
</dl>
<h3>System Interaction Functions</h3>
<dl>
    <dt>FRE( <var>expr</var> )<dd>Garbage collect strings (returns 0)
    <dt>PDL( <var>expr</var> )<dd>Paddle position (paddle number)
    <dt>POS( <var>expr</var> )<dd>Horizontal cursor position
    <dt>SCRN( <var>expr</var>, <var>expr</var> )<dd>Lores color at pixel (x,y)
    <dt>HSCRN( <var>expr</var>, <var>expr</var> )<dd>Hires color at pixel (x,y)<a href="#Extension_HSCRN">[4]</a>
    <dt>USR( <var>expr</var> )<dd>Execute assembly code at address, return accumulator value <var>- NOT IMPLEMENTED</var>
</dl>
<h3>User Defined Functions</h3>
<dl>
    <dt>FN <var>f</var>( <var>expr</var> )<dd>Execute user defined function <a href="#Extension_StringFuncs">[1]</a>
</dl>

<h3 id="Function_Compatibility_Shims">Function Compatibility Shims</h3>
<dl>
    <dt id="peek">PEEK( <var>expr</var> )<dd>Value at memory location
        <ul>
            <li><code>PEEK(32)</code> - Text window left edge
            <li><code>PEEK(33)</code> - Text window width
            <li><code>PEEK(34)</code> - Text window top edge
            <li><code>PEEK(35)</code> - Text window bottom
            <li><code>PEEK(36)</code> - Text cursor x
            <li><code>PEEK(37)</code> - Text cursor y
            <li><code>PEEK(78)</code> &amp; <code>PEEK(79)</code> - Random-Number Field
            <li><code>PEEK(222)</code> - Last error code
            <li><code>PEEK(230)</code> - Hi-Res plotting page (32 = page 1, 64 = page 2)
            <li><code>PEEK(49152)</code> - Read Keyboard
            <li><code>PEEK(49168)</code> - Clear Keyboard strobe
            <li><code>PEEK(49200)</code> - Click Speaker (no-op)
            <li><code>PEEK(49248)</code> - Read Paddle Button #3 - <em>Use the PageDown key</em>
            <li><code>PEEK(49249)</code> - Read Paddle Button #0 - <em>Use the Home key</em>
            <li><code>PEEK(49250)</code> - Read Paddle Button #1 - <em>Use the End key</em>
            <li><code>PEEK(49251)</code> - Read Paddle Button #2 - <em>Use the PageUp or Shift key</em>
        </ul>

</dl>

<!-- ================================================== -->
<h2 id="Operators">Operators</h2>
<!-- ================================================== -->

<h3>Comparison Operators</h3>
<dl>
    <dt>=<dd>Equality<a href="#Extensions_DoubleEquals">[2]</a>
    <dt>&lt;<dd>Less than
    <dt>&gt;<dd>Greater than
    <dt>&lt;=<dt>=&lt;<dd>Less than or equal
    <dt>&gt;=<dt>=&gt;<dd>Greater than or equal
    <dt>&lt;&gt;<dt>&gt;&lt;<dd>Not equal
</dl>
<h3>Boolean Operators</h3>
<dl>
    <dt>AND<dd>Conjunction
    <dt>OR<dd>Disjunction
    <dt>NOT<dd>Negation
</dl>
<h3>Arithmetic Operators</h3>
<dl>
    <dt>^<dd>Exponentiation
    <dt>*<dd>Multiplication
    <dt>/<dd>Division
    <dt>+<dd>Addition
    <dt>-<dd>Subtraction
</dl>
<h3>String Operators</h3>
<dl>
    <dt>+<dd>String Concatenation
</dl>

<!-- ================================================== -->
<h2>Error Codes</h2>
<!-- ================================================== -->
<p>Error codes can be determined by calling
<code>PEEK(222)</code> in an ONERR handler.</p>

<dl>
    <dt>0<dd>Next without for
    <dt>16<dd>Syntax error <em>- Not generated</em>
    <dt>22<dd>Return without gosub
    <dt>42<dd>Out of data
    <dt>53<dd>Illegal quantity
    <dt>69<dd>Overflow
    <dt>77<dd>Out of memory <em>- Not generated by all browsers</em>
    <dt>90<dd>Undefined statement
    <dt>107<dd>Bad subscript
    <dt>120<dd>Redimensioned array
    <dt>133<dd>Division by zero
    <dt>163<dd>Type mismatch
    <dt>176<dd>String too long <em>- Not generated</em>
    <dt>191<dd>Formula too complex <em>- Not generated by all browsers</em>
    <dt>224<dd>Undefined function
    <dt>254<dd>Re-enter
    <dt>255<dd>Break
</dl>



<!-- ================================================== -->
<h2 id="DOSQuickReference">DOS 3.3 / ProDOS Quick Reference</h2>
<!-- ================================================== -->

<p>See also</p>
<ul>
	<li><a href="http://www.xs4all.nl/~fjkraan/comp/apple2faq/app2doscmdfaq.html">Apple II DOS &amp; Commands FAQ</a>
	<li><a href="http://www.textfiles.com/apple/ANATOMY/">Apple II Textfiles: the DOS 3.3 Anatomy</a>
	<li><a href="http://vectronicsappleworld.com/appleii/dos.html">Vectronic's Apple World DOS 3.3 and ProDOS Guide</a>
</ul>

<h3>DOS Commands</h3>
<dl>
    <dt>MON[,C][,I][,O]<dd>Traces DOS 3.3 commands ('Commands', 'Input' and 'Output')
    <dt>NOMON[,C][,I][,O]            <dd>Cancels tracing of DOS 3.3 commands ('Commands', 'Input' and 'Output')
    <dt>OPEN <var>filename</var>[,L<var>len</var>]         <dd>Opens a text file.
    <dt>APPEND <var>filename</var>              <dd>Appends to a text file.
    <dt>CLOSE [<var>filename</var>]             <dd>Closes specified (or all) open text files.
    <dt>POSITION <var>filename</var>[,R<var>num</var>]     <dd>Advances position in text file.
    <dt>READ <var>filename</var>[,R<var>num</var>][,B<var>byte</var>] <dd>Reads from a text file.
    <dt>WRITE <var>filename</var>[,R<var>num</var>][,B<var>byte</var>]<dd>Writes to a text file
    <dt>DELETE <var>filename</var>              <dd>Delete a file
    <dt>RENAME <var>oldname</var>,<var>newname</var>       <dd>Rename a file
    <dt>PR# <var>slot</var>          <dd>Same as the BASIC command
</dl>
<p><var>Other DOS commands are NOT IMPLEMENTED.</var></p>
<p>Some sample files are present in a server-side store loaded on-demand into a client-side virtual file system (VFS). Creating or writing to a file will write to the VFS. Subsequent reads will read from the VFS. Files may be deleted from the VFS. These changes will not persist if the browser is refreshed or closed.</p>

<h3>DOS Error Codes</h3>

<p>Error codes can be determined by calling
<code>PEEK(222)</code> in an ONERR handler.</p>

<dl>
    <dt>1<dd>Language not available <em>- Not generated</em>
    <dt>2<dd>Range error <em>- Not generated</em>
    <dt>4<dd>Write protected <em>- Not generated</em>
    <dt>5<dd>End of data
    <dt>6<dd>File not found
    <dt>7<dd>Volume mismatch <em>- Not generated</em>
    <dt>8<dd>I/O error <em>- Not generated</em>
    <dt>9<dd>Disk full <em>- Not generated</em>
    <dt>10<dd>File locked <em>- Not generated</em>
    <dt>11<dd>Invalid option
    <dt>12<dd>No buffers available <em>- Not generated</em>
    <dt>13<dd>File type mismatch <em>- Not generated</em>
    <dt>14<dd>Program too large <em>- Not generated</em>
    <dt>15<dd>Not direct command <em>- Not generated</em>
</dl>

<!-- ================================================== -->
<h2>Input and Output</h2>
<!-- ================================================== -->

<h3>Input</h3>

<p>
The page attempts to emulate an Apple II keyboard. Note that the keyboard
API available in Web browsers is not standardized and is poorly defined;
a best-effort has been made testing on available systems and browsers.
</p>

<p>
The <em>Open Apple</em> and <em>Closed Apple</em> keys on later Apple II models
correspond to the Button #0 and Button #1 inputs and are emulated on modern keyboards
with the <em>Home</em> and <em>End</em> keys respectively. (Unfortunately, browsers
are currently unable to distinguish the left and right <em>Alt</em> or <em>Command</em> keys.)
</p>

<p>
Since the <em>Tab</em> key is necessary for keyboard access to browser functions and
the rest of the web page, it is not available. Otherwise, special keys can be detected
using <code>GET</code> (blocking) or <code>PEEK(49152)</code> (non-blocking):
</p>

<table style="margin-left: 3em;">
    <tr><td><code>CHR$(8)</code><td>Left arrow
    <tr><td><code>CHR$(10)</code><td>Down arrow
    <tr><td><code>CHR$(11)</code><td>Up arrow
    <tr><td><code>CHR$(13)</code><td>Enter or Return
    <tr><td><code>CHR$(21)</code><td>Right arrow
    <tr><td><code>CHR$(24)</code><td>Clear
    <tr><td><code>CHR$(27)</code><td>Escape
    <tr><td><code>CHR$(127)</code><td>Delete or Backspace
</table>


<h3>Output</h3>

<p>
The page attempts to emulate the display of an Apple II system with
80-column card firmware, which can be activated with the
<code>PR#3</code> statement.
</p>

<p>
When printing characters, <code>CHR$</code> functions as expected for values
from 32-126 (printable ASCII). Control characters have the typical Apple II meanings:
</p>

<table style="margin-left: 3em;">
    <tr><td><code>CHR$(4)</code><td>DOS command escape prefix
    <tr><td><code>CHR$(7)</code><td>Make a "beep" (if your browser supports it)
    <tr><td><code>CHR$(8)</code><td>Backspace (move cursor left, wrap up)
    <tr><td><code>CHR$(10)</code><td>Line feed (move cursor down)
    <tr><td><code>CHR$(13)</code><td>Carriage return (move cursor down and to left edge)
    <tr><td><code>CHR$(127)</code><td>Displays a cursor glyph
</table>

<p>
If 80-column firmware is active, the following additional codes are available:
</p>
<table style="margin-left: 3em;">
    <tr><td><code>CHR$(11)</code><td>Clears from the cursor position to the end of the window
    <tr><td><code>CHR$(12)</code><td>Move cursor to upper left and clear window
    <tr><td><code>CHR$(14)</code><td>Set normal text output
    <tr><td><code>CHR$(15)</code><td>Set inverse text output
    <tr><td><code>CHR$(17)</code><td>Set display to 40 columns
    <tr><td><code>CHR$(18)</code><td>Set display to 80 columns
    <tr><td><code>CHR$(21)</code><td>Deactivate the 80-column firmware
    <tr><td><code>CHR$(22)</code><td>Scroll display down, preserving cursor position
    <tr><td><code>CHR$(23)</code><td>Scroll display up, preserving cursor position
    <tr><td><code>CHR$(24)</code><td>Disable mousetext
    <tr><td><code>CHR$(25)</code><td>Move cursor to upper left (but don't clear window)
    <tr><td><code>CHR$(26)</code><td>Clear the current line
    <tr><td><code>CHR$(27)</code><td>Enable mousetext
    <tr><td><code>CHR$(28)</code><td>Forward space (move cursor right, wrap down)
    <tr><td><code>CHR$(29)</code><td>Clear from cursor position to end of line
</table>

<p>
The text window can be changed and cursor finely controlled
with <code>POKE 32,<var>n</var></code> ... <code>POKE 37,<var>n</var></code>
</p>

<!-- ================================================== -->
<h2>Process and Grammars</h2>
<!-- ================================================== -->
<p><var>For the even geekier in the audience...</var></p>

<p>Compilation is done by splitting the input into tokens which are then
consumed by a recursive descent parser which outputs a JavaScript
object representing the program.</p>

<p>The token types (treated as terminals) are
    <code>reserved</code>,
    <code>identifier</code>,
    <code>string-literal</code>,
    <code>number-literal</code>,
    <code>operator</code>,
    <code>line-number</code>,
    <code>separator</code>,
    <code>remark</code>,
    <code>data-declaration</code>
    - take a peek at the code if you want the gruesome details. Source lines may
    only start with line numbers or (as an extension) separators. Special statement
    parsing is done while lexing: <code>REM</code> consumes anything to the next
    line break, and <code>DATA</code> statements yeild an array of strings
    from the comma-delimited, optionally-quoted values in the source.
</p>

<ul>
<li><var>[x]</var> zero or one occurences of x
<li><var>{x}</var> zero or more occurences of x
<li><var>x | y</var> one of either x or y
<li><var>(x)</var> grouping construct
</ul>

<p>Overall program parsing is done with a recursive descent parser.</p>

<pre>
    Program                  = Line { Line }
    Line                     = line-number Statement { separator Statement }
    Statement                = data-declaration | remark | Command | EmptyStatement
    Command                  = identifier /*...*/ | reserved /*...*/
</pre>

<p>Statements ("commands" in the above grammar) are parsed with distinct cases for each statement type.
Most statements compile into a function call to a library of Applesoft routines. Expressions are parsed
with a standard recursive descent parser. The parser generates JavaScript expressions for each expression,
which are used as arguments for the library calls.</p>

<pre>
    Expression               = OrExpression
    OrExpression             = AndExpression [ 'OR' AndExpression ... ]
    AndExpression            = RelationalExpression [ 'AND' RelationalExpression ... ]
    RelationalExpression     = AdditiveExpression [ ( '=' | '&lt;' | '&gt;' | '&lt;=' | '=&lt;' | '&gt;=' | '=&gt;' | '&lt;&gt;' | '&gt;&lt;' ) AdditiveExpression ... ]
    AdditiveExpression       = MultiplicativeExpression [ ( '+' | '-' ) MultiplicativeExpression ... ]
    MultiplicativeExpression = PowerExpression [ ( '*' | '/' ) PowerExpression ... ]
    PowerExpression          = UnaryExpression [ '^' UnaryExpression ]
    UnaryExpression          = ( '+' | '-' | 'NOT' ) UnaryExpression
                              | FinalExpression
    FinalExpression          = number-literal
                              | string-literal
                              | 'FN' user_function_name '(' Expression ')'
                              | reserved '(' Expression [, Expression ...] ')'
                              | identifier [ '(' Expression [, Expression ...] ')' ]
                              | '(' Expression ')'
</pre>


<p>Since Applesoft supports re-entrant error handling and synchronous input,
the output of the compiler is an array of statement-functions plus a driver
function which implements the logic for walking over the array.<p>

<!-- ================================================== -->
<h2 id="Extensions">Extensions beyond Standard Applesoft</h2>
<!-- ================================================== -->
<ul style="list-style: none;">
    <li id="Extension_StringFuncs">
        [1] <code>DEF FN</code> supports string and integer functions
        e.g. <code>DEF FN IN$(X$) = " " + X$</code>
        (but return type must still match argument type)
    <li id="Extension_DoubleEquals">
        [2] <code>==</code> is supported for equality comparisons, in addition to <code>=</code>
    <li id="Extension_CHR">
        [3] When printing characters, <code>CHR$</code> values greater than 255 generate glyphs that might be useful for certain maze games.
    <li id="Extension_HSCRN">
        [4] <code>HSCRN(<var>x</var>, <var>y</var>)</code> is added to allow reading the
        hires screen. On a real Apple this required a machine-language routine (or a shape table and XDRAW).

</ul>

<script>
(function (el) {
    var html = [];
    el.innerHTML = "";

    var level = 1, newLevel, unique = 10000, key, c
    for (c = document.body.firstChild; c; c = c.nextSibling) {
        if( c.nodeName === "H2" || c.nodeName === "H3" ) {
            newLevel = parseInt(c.nodeName.charAt(1), 10);

            if (newLevel > level) {
                html.push( "<ol>" );
            }
            else if (level > newLevel) {
                html.push( "<"+"/ol>" );
            }

            key = "key_" + unique++;

            html.push( "<li>",
                       "<a href='#"+key+"'>",
                       c.textContent !== undefined ? c.textContent : c.innerText,
                       "<"+"/a>" ,
                       "<"+"/li>" );

            c.setAttribute('id', key);

            level = newLevel;

        }
    }

    while( level > 1 ) {
        html.push( "<"+"/ol>" );
        --level;
    }
    el.innerHTML = html.join("");
}(document.getElementById("toc")));

</script>
